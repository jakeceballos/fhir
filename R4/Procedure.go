// Code generated by schema-generate. DO NOT EDIT.

package R4

import (
    "errors"
    "encoding/json"
    "fmt"
    "bytes"
)

// Procedure An action that is or was performed on or for a patient. This can be a physical intervention like an operation, or less invasive like long term services, counseling, or hypnotherapy.
type Procedure struct {

  // Individual who is making the procedure statement.
  Asserter *Reference `json:"asserter,omitempty"`

  // A reference to a resource that contains details of the request for this procedure.
  BasedOn []*Reference `json:"basedOn,omitempty"`

  // Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
  BodySite []*CodeableConcept `json:"bodySite,omitempty"`

  // A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
  Category *CodeableConcept `json:"category,omitempty"`

  // The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
  Code *CodeableConcept `json:"code,omitempty"`

  // Any complications that occurred during the procedure, or in the immediate post-performance period. These are generally tracked separately from the notes, which will typically describe the procedure itself rather than any 'post procedure' issues.
  Complication []*CodeableConcept `json:"complication,omitempty"`

  // Any complications that occurred during the procedure, or in the immediate post-performance period.
  ComplicationDetail []*Reference `json:"complicationDetail,omitempty"`

  // These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
  Contained []interface{} `json:"contained,omitempty"`

  // The Encounter during which this Procedure was created or performed or to which the creation of this record is tightly associated.
  Encounter *Reference `json:"encounter,omitempty"`

  // May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  Extension []*Extension `json:"extension,omitempty"`

  // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
  FocalDevice []*ProcedureFocalDevice `json:"focalDevice,omitempty"`

  // If the procedure required specific follow up - e.g. removal of sutures. The follow up may be represented as a simple note or could potentially be more complex, in which case the CarePlan resource can be used.
  FollowUp []*CodeableConcept `json:"followUp,omitempty"`

  // The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.
  Id string `json:"id,omitempty"`

  // Business identifiers assigned to this procedure by the performer or other systems which remain constant as the resource is updated and is propagated from server to server.
  Identifier []*Identifier `json:"identifier,omitempty"`

  // A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
  ImplicitRules string `json:"implicitRules,omitempty"`

  // The URL pointing to a FHIR-defined protocol, guideline, order set or other definition that is adhered to in whole or in part by this Procedure.
  InstantiatesCanonical []string `json:"instantiatesCanonical,omitempty"`

  // The URL pointing to an externally maintained protocol, guideline, order set or other definition that is adhered to in whole or in part by this Procedure.
  InstantiatesUri []string `json:"instantiatesUri,omitempty"`

  // The base language in which the resource is written.
  Language string `json:"language,omitempty"`

  // The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
  Location *Reference `json:"location,omitempty"`

  // The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
  Meta *Meta `json:"meta,omitempty"`

  // May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  // 
  // Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  ModifierExtension []*Extension `json:"modifierExtension,omitempty"`

  // Any other notes and comments about the procedure.
  Note []*Annotation `json:"note,omitempty"`

  // The outcome of the procedure - did it resolve the reasons for the procedure being performed?
  Outcome *CodeableConcept `json:"outcome,omitempty"`

  // A larger event of which this particular procedure is a component or step.
  PartOf []*Reference `json:"partOf,omitempty"`

  // Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
  PerformedAge *Age `json:"performedAge,omitempty"`

  // Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
  PerformedDateTime string `json:"performedDateTime,omitempty"`

  // Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
  PerformedPeriod *Period `json:"performedPeriod,omitempty"`

  // Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
  PerformedRange *Range `json:"performedRange,omitempty"`

  // Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
  PerformedString string `json:"performedString,omitempty"`

  // Limited to "real" people rather than equipment.
  Performer []*ProcedurePerformer `json:"performer,omitempty"`

  // The coded reason why the procedure was performed. This may be a coded entity of some type, or may simply be present as text.
  ReasonCode []*CodeableConcept `json:"reasonCode,omitempty"`

  // The justification of why the procedure was performed.
  ReasonReference []*Reference `json:"reasonReference,omitempty"`

  // Individual who recorded the record and takes responsibility for its content.
  Recorder *Reference `json:"recorder,omitempty"`

  // This could be a histology result, pathology report, surgical report, etc.
  Report []*Reference `json:"report,omitempty"`

  // This is a Procedure resource
  ResourceType interface{} `json:"resourceType"`

  // A code specifying the state of the procedure. Generally, this will be the in-progress or completed state.
  Status string `json:"status,omitempty"`

  // Captures the reason for the current state of the procedure.
  StatusReason *CodeableConcept `json:"statusReason,omitempty"`

  // The person, animal or group on which the procedure was performed.
  Subject *Reference `json:"subject"`

  // A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Text *Narrative `json:"text,omitempty"`

  // Identifies coded items that were used as part of the procedure.
  UsedCode []*CodeableConcept `json:"usedCode,omitempty"`

  // Identifies medications, devices and any other substance used as part of the procedure.
  UsedReference []*Reference `json:"usedReference,omitempty"`
}

func (strct *Procedure) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "asserter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"asserter\": ")
	if tmp, err := json.Marshal(strct.Asserter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "basedOn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"basedOn\": ")
	if tmp, err := json.Marshal(strct.BasedOn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "bodySite" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"bodySite\": ")
	if tmp, err := json.Marshal(strct.BodySite); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "category" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"category\": ")
	if tmp, err := json.Marshal(strct.Category); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "code" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"code\": ")
	if tmp, err := json.Marshal(strct.Code); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "complication" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"complication\": ")
	if tmp, err := json.Marshal(strct.Complication); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "complicationDetail" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"complicationDetail\": ")
	if tmp, err := json.Marshal(strct.ComplicationDetail); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contained" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contained\": ")
	if tmp, err := json.Marshal(strct.Contained); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "encounter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"encounter\": ")
	if tmp, err := json.Marshal(strct.Encounter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "extension" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"extension\": ")
	if tmp, err := json.Marshal(strct.Extension); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "focalDevice" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"focalDevice\": ")
	if tmp, err := json.Marshal(strct.FocalDevice); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "followUp" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"followUp\": ")
	if tmp, err := json.Marshal(strct.FollowUp); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "identifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"identifier\": ")
	if tmp, err := json.Marshal(strct.Identifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "implicitRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"implicitRules\": ")
	if tmp, err := json.Marshal(strct.ImplicitRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "instantiatesCanonical" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"instantiatesCanonical\": ")
	if tmp, err := json.Marshal(strct.InstantiatesCanonical); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "instantiatesUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"instantiatesUri\": ")
	if tmp, err := json.Marshal(strct.InstantiatesUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "language" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"language\": ")
	if tmp, err := json.Marshal(strct.Language); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "modifierExtension" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"modifierExtension\": ")
	if tmp, err := json.Marshal(strct.ModifierExtension); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "note" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"note\": ")
	if tmp, err := json.Marshal(strct.Note); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "outcome" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"outcome\": ")
	if tmp, err := json.Marshal(strct.Outcome); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "partOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"partOf\": ")
	if tmp, err := json.Marshal(strct.PartOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "performedAge" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"performedAge\": ")
	if tmp, err := json.Marshal(strct.PerformedAge); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "performedDateTime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"performedDateTime\": ")
	if tmp, err := json.Marshal(strct.PerformedDateTime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "performedPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"performedPeriod\": ")
	if tmp, err := json.Marshal(strct.PerformedPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "performedRange" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"performedRange\": ")
	if tmp, err := json.Marshal(strct.PerformedRange); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "performedString" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"performedString\": ")
	if tmp, err := json.Marshal(strct.PerformedString); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "performer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"performer\": ")
	if tmp, err := json.Marshal(strct.Performer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "reasonCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"reasonCode\": ")
	if tmp, err := json.Marshal(strct.ReasonCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "reasonReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"reasonReference\": ")
	if tmp, err := json.Marshal(strct.ReasonReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recorder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"recorder\": ")
	if tmp, err := json.Marshal(strct.Recorder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "report" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"report\": ")
	if tmp, err := json.Marshal(strct.Report); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "resourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "statusReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"statusReason\": ")
	if tmp, err := json.Marshal(strct.StatusReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Subject" field is required
    if strct.Subject == nil {
        return nil, errors.New("subject is a required field")
    }
    // Marshal the "subject" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"subject\": ")
	if tmp, err := json.Marshal(strct.Subject); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "text" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "usedCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"usedCode\": ")
	if tmp, err := json.Marshal(strct.UsedCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "usedReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"usedReference\": ")
	if tmp, err := json.Marshal(strct.UsedReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Procedure) UnmarshalJSON(b []byte) error {
    resourceTypeReceived := false
    subjectReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asserter":
            if err := json.Unmarshal([]byte(v), &strct.Asserter); err != nil {
                return err
             }
        case "basedOn":
            if err := json.Unmarshal([]byte(v), &strct.BasedOn); err != nil {
                return err
             }
        case "bodySite":
            if err := json.Unmarshal([]byte(v), &strct.BodySite); err != nil {
                return err
             }
        case "category":
            if err := json.Unmarshal([]byte(v), &strct.Category); err != nil {
                return err
             }
        case "code":
            if err := json.Unmarshal([]byte(v), &strct.Code); err != nil {
                return err
             }
        case "complication":
            if err := json.Unmarshal([]byte(v), &strct.Complication); err != nil {
                return err
             }
        case "complicationDetail":
            if err := json.Unmarshal([]byte(v), &strct.ComplicationDetail); err != nil {
                return err
             }
        case "contained":
            if err := json.Unmarshal([]byte(v), &strct.Contained); err != nil {
                return err
             }
        case "encounter":
            if err := json.Unmarshal([]byte(v), &strct.Encounter); err != nil {
                return err
             }
        case "extension":
            if err := json.Unmarshal([]byte(v), &strct.Extension); err != nil {
                return err
             }
        case "focalDevice":
            if err := json.Unmarshal([]byte(v), &strct.FocalDevice); err != nil {
                return err
             }
        case "followUp":
            if err := json.Unmarshal([]byte(v), &strct.FollowUp); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "identifier":
            if err := json.Unmarshal([]byte(v), &strct.Identifier); err != nil {
                return err
             }
        case "implicitRules":
            if err := json.Unmarshal([]byte(v), &strct.ImplicitRules); err != nil {
                return err
             }
        case "instantiatesCanonical":
            if err := json.Unmarshal([]byte(v), &strct.InstantiatesCanonical); err != nil {
                return err
             }
        case "instantiatesUri":
            if err := json.Unmarshal([]byte(v), &strct.InstantiatesUri); err != nil {
                return err
             }
        case "language":
            if err := json.Unmarshal([]byte(v), &strct.Language); err != nil {
                return err
             }
        case "location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
        case "meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "modifierExtension":
            if err := json.Unmarshal([]byte(v), &strct.ModifierExtension); err != nil {
                return err
             }
        case "note":
            if err := json.Unmarshal([]byte(v), &strct.Note); err != nil {
                return err
             }
        case "outcome":
            if err := json.Unmarshal([]byte(v), &strct.Outcome); err != nil {
                return err
             }
        case "partOf":
            if err := json.Unmarshal([]byte(v), &strct.PartOf); err != nil {
                return err
             }
        case "performedAge":
            if err := json.Unmarshal([]byte(v), &strct.PerformedAge); err != nil {
                return err
             }
        case "performedDateTime":
            if err := json.Unmarshal([]byte(v), &strct.PerformedDateTime); err != nil {
                return err
             }
        case "performedPeriod":
            if err := json.Unmarshal([]byte(v), &strct.PerformedPeriod); err != nil {
                return err
             }
        case "performedRange":
            if err := json.Unmarshal([]byte(v), &strct.PerformedRange); err != nil {
                return err
             }
        case "performedString":
            if err := json.Unmarshal([]byte(v), &strct.PerformedString); err != nil {
                return err
             }
        case "performer":
            if err := json.Unmarshal([]byte(v), &strct.Performer); err != nil {
                return err
             }
        case "reasonCode":
            if err := json.Unmarshal([]byte(v), &strct.ReasonCode); err != nil {
                return err
             }
        case "reasonReference":
            if err := json.Unmarshal([]byte(v), &strct.ReasonReference); err != nil {
                return err
             }
        case "recorder":
            if err := json.Unmarshal([]byte(v), &strct.Recorder); err != nil {
                return err
             }
        case "report":
            if err := json.Unmarshal([]byte(v), &strct.Report); err != nil {
                return err
             }
        case "resourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
            resourceTypeReceived = true
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "statusReason":
            if err := json.Unmarshal([]byte(v), &strct.StatusReason); err != nil {
                return err
             }
        case "subject":
            if err := json.Unmarshal([]byte(v), &strct.Subject); err != nil {
                return err
             }
            subjectReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
        case "usedCode":
            if err := json.Unmarshal([]byte(v), &strct.UsedCode); err != nil {
                return err
             }
        case "usedReference":
            if err := json.Unmarshal([]byte(v), &strct.UsedReference); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if resourceType (a required property) was received
    if !resourceTypeReceived {
        return errors.New("\"resourceType\" is required but was not present")
    }
    // check if subject (a required property) was received
    if !subjectReceived {
        return errors.New("\"subject\" is required but was not present")
    }
    return nil
}
