// Code generated by schema-generate. DO NOT EDIT.

package R4

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// ResearchStudy A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.
type ResearchStudy struct {

  // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
  Arm []*ResearchStudyArm `json:"arm,omitempty"`

  // Codes categorizing the type of study such as investigational vs. observational, type of blinding, type of randomization, safety vs. efficacy, etc.
  Category []*CodeableConcept `json:"category,omitempty"`

  // The condition that is the focus of the study.  For example, In a study to examine risk factors for Lupus, might have as an inclusion criterion "healthy volunteer", but the target condition code would be a Lupus SNOMED code.
  Condition []*CodeableConcept `json:"condition,omitempty"`

  // Contact details to assist a user in learning more about or engaging with the study.
  Contact []*ContactDetail `json:"contact,omitempty"`

  // These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
  Contained []interface{} `json:"contained,omitempty"`

  // A full description of how the study is being conducted.
  Description string `json:"description,omitempty"`

  // Reference to a Group that defines the criteria for and quantity of subjects participating in the study.  E.g. " 200 female Europeans between the ages of 20 and 45 with early onset diabetes".
  Enrollment []*Reference `json:"enrollment,omitempty"`

  // May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  Extension []*Extension `json:"extension,omitempty"`

  // The medication(s), food(s), therapy(ies), device(s) or other concerns or interventions that the study is seeking to gain more information about.
  Focus []*CodeableConcept `json:"focus,omitempty"`

  // The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.
  Id string `json:"id,omitempty"`

  // Identifiers assigned to this research study by the sponsor or other systems.
  Identifier []*Identifier `json:"identifier,omitempty"`

  // A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
  ImplicitRules string `json:"implicitRules,omitempty"`

  // Key terms to aid in searching for or filtering the study.
  Keyword []*CodeableConcept `json:"keyword,omitempty"`

  // The base language in which the resource is written.
  Language string `json:"language,omitempty"`

  // Indicates a country, state or other region where the study is taking place.
  Location []*CodeableConcept `json:"location,omitempty"`

  // The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
  Meta *Meta `json:"meta,omitempty"`

  // May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  // 
  // Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  ModifierExtension []*Extension `json:"modifierExtension,omitempty"`

  // Comments made about the study by the performer, subject or other participants.
  Note []*Annotation `json:"note,omitempty"`

  // A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
  Objective []*ResearchStudyObjective `json:"objective,omitempty"`

  // A larger research study of which this particular study is a component or step.
  PartOf []*Reference `json:"partOf,omitempty"`

  // Identifies the start date and the expected (or actual, depending on status) end date for the study.
  Period *Period `json:"period,omitempty"`

  // The stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation.
  Phase *CodeableConcept `json:"phase,omitempty"`

  // The type of study based upon the intent of the study's activities. A classification of the intent of the study.
  PrimaryPurposeType *CodeableConcept `json:"primaryPurposeType,omitempty"`

  // A researcher in a study who oversees multiple aspects of the study, such as concept development, protocol writing, protocol submission for IRB approval, participant recruitment, informed consent, data collection, analysis, interpretation and presentation.
  PrincipalInvestigator *Reference `json:"principalInvestigator,omitempty"`

  // The set of steps expected to be performed as part of the execution of the study.
  Protocol []*Reference `json:"protocol,omitempty"`

  // A description and/or code explaining the premature termination of the study.
  ReasonStopped *CodeableConcept `json:"reasonStopped,omitempty"`

  // Citations, references and other related documents.
  RelatedArtifact []*RelatedArtifact `json:"relatedArtifact,omitempty"`

  // This is a ResearchStudy resource
  ResourceType interface{} `json:"resourceType"`

  // A facility in which study activities are conducted.
  Site []*Reference `json:"site,omitempty"`

  // An organization that initiates the investigation and is legally responsible for the study.
  Sponsor *Reference `json:"sponsor,omitempty"`

  // The current state of the study.
  Status interface{} `json:"status,omitempty"`

  // A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Text *Narrative `json:"text,omitempty"`

  // A short, descriptive user-friendly label for the study.
  Title string `json:"title,omitempty"`
}

func (strct *ResearchStudy) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "arm" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"arm\": ")
	if tmp, err := json.Marshal(strct.Arm); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "category" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"category\": ")
	if tmp, err := json.Marshal(strct.Category); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "condition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"condition\": ")
	if tmp, err := json.Marshal(strct.Condition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contact\": ")
	if tmp, err := json.Marshal(strct.Contact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contained" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contained\": ")
	if tmp, err := json.Marshal(strct.Contained); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enrollment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enrollment\": ")
	if tmp, err := json.Marshal(strct.Enrollment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "extension" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"extension\": ")
	if tmp, err := json.Marshal(strct.Extension); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "focus" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"focus\": ")
	if tmp, err := json.Marshal(strct.Focus); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "identifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"identifier\": ")
	if tmp, err := json.Marshal(strct.Identifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "implicitRules" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"implicitRules\": ")
	if tmp, err := json.Marshal(strct.ImplicitRules); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "keyword" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"keyword\": ")
	if tmp, err := json.Marshal(strct.Keyword); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "language" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"language\": ")
	if tmp, err := json.Marshal(strct.Language); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "modifierExtension" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"modifierExtension\": ")
	if tmp, err := json.Marshal(strct.ModifierExtension); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "note" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"note\": ")
	if tmp, err := json.Marshal(strct.Note); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "objective" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"objective\": ")
	if tmp, err := json.Marshal(strct.Objective); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "partOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"partOf\": ")
	if tmp, err := json.Marshal(strct.PartOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "period" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"period\": ")
	if tmp, err := json.Marshal(strct.Period); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "phase" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"phase\": ")
	if tmp, err := json.Marshal(strct.Phase); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "primaryPurposeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"primaryPurposeType\": ")
	if tmp, err := json.Marshal(strct.PrimaryPurposeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "principalInvestigator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"principalInvestigator\": ")
	if tmp, err := json.Marshal(strct.PrincipalInvestigator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "protocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "reasonStopped" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"reasonStopped\": ")
	if tmp, err := json.Marshal(strct.ReasonStopped); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "relatedArtifact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"relatedArtifact\": ")
	if tmp, err := json.Marshal(strct.RelatedArtifact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "resourceType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resourceType\": ")
	if tmp, err := json.Marshal(strct.ResourceType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "site" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"site\": ")
	if tmp, err := json.Marshal(strct.Site); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sponsor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sponsor\": ")
	if tmp, err := json.Marshal(strct.Sponsor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "text" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResearchStudy) UnmarshalJSON(b []byte) error {
    resourceTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "arm":
            if err := json.Unmarshal([]byte(v), &strct.Arm); err != nil {
                return err
             }
        case "category":
            if err := json.Unmarshal([]byte(v), &strct.Category); err != nil {
                return err
             }
        case "condition":
            if err := json.Unmarshal([]byte(v), &strct.Condition); err != nil {
                return err
             }
        case "contact":
            if err := json.Unmarshal([]byte(v), &strct.Contact); err != nil {
                return err
             }
        case "contained":
            if err := json.Unmarshal([]byte(v), &strct.Contained); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enrollment":
            if err := json.Unmarshal([]byte(v), &strct.Enrollment); err != nil {
                return err
             }
        case "extension":
            if err := json.Unmarshal([]byte(v), &strct.Extension); err != nil {
                return err
             }
        case "focus":
            if err := json.Unmarshal([]byte(v), &strct.Focus); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "identifier":
            if err := json.Unmarshal([]byte(v), &strct.Identifier); err != nil {
                return err
             }
        case "implicitRules":
            if err := json.Unmarshal([]byte(v), &strct.ImplicitRules); err != nil {
                return err
             }
        case "keyword":
            if err := json.Unmarshal([]byte(v), &strct.Keyword); err != nil {
                return err
             }
        case "language":
            if err := json.Unmarshal([]byte(v), &strct.Language); err != nil {
                return err
             }
        case "location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
        case "meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "modifierExtension":
            if err := json.Unmarshal([]byte(v), &strct.ModifierExtension); err != nil {
                return err
             }
        case "note":
            if err := json.Unmarshal([]byte(v), &strct.Note); err != nil {
                return err
             }
        case "objective":
            if err := json.Unmarshal([]byte(v), &strct.Objective); err != nil {
                return err
             }
        case "partOf":
            if err := json.Unmarshal([]byte(v), &strct.PartOf); err != nil {
                return err
             }
        case "period":
            if err := json.Unmarshal([]byte(v), &strct.Period); err != nil {
                return err
             }
        case "phase":
            if err := json.Unmarshal([]byte(v), &strct.Phase); err != nil {
                return err
             }
        case "primaryPurposeType":
            if err := json.Unmarshal([]byte(v), &strct.PrimaryPurposeType); err != nil {
                return err
             }
        case "principalInvestigator":
            if err := json.Unmarshal([]byte(v), &strct.PrincipalInvestigator); err != nil {
                return err
             }
        case "protocol":
            if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
                return err
             }
        case "reasonStopped":
            if err := json.Unmarshal([]byte(v), &strct.ReasonStopped); err != nil {
                return err
             }
        case "relatedArtifact":
            if err := json.Unmarshal([]byte(v), &strct.RelatedArtifact); err != nil {
                return err
             }
        case "resourceType":
            if err := json.Unmarshal([]byte(v), &strct.ResourceType); err != nil {
                return err
             }
            resourceTypeReceived = true
        case "site":
            if err := json.Unmarshal([]byte(v), &strct.Site); err != nil {
                return err
             }
        case "sponsor":
            if err := json.Unmarshal([]byte(v), &strct.Sponsor); err != nil {
                return err
             }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if resourceType (a required property) was received
    if !resourceTypeReceived {
        return errors.New("\"resourceType\" is required but was not present")
    }
    return nil
}
